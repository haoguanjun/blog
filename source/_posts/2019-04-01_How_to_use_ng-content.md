---
title: 投影：如何使用 `ng-content` 改进组件的接口设计     
date: 2019-04-01
categories: angular
---
本文中，我们将学习如何使用该特性来设计简单但是强大，本文关注组件设计。
为了学习内容投影，我们用它构建一个小的组件 ( 一个 Font Awesome 输入框 )。我们将研究内容投影是如何工作的，什么时候使用它，以及为什么，它为什么可以改进我们大量的组件设计。
<!-- more -->
# 投影：如何使用 `ng-content` 改进组件的接口设计

Angular 特性中帮助我们构建可复用组件之一是内容投影和 `ng-content`。
本文中，我们将学习如何使用该特性来设计简单但是强大，本文关注组件设计。
为了学习内容投影，我们用它构建一个小的组件 ( 一个 Font Awesome 输入框 )。我们将研究内容投影是如何工作的，什么时候使用它，以及为什么，它为什么可以改进我们大量的组件设计。
[最终的组件在这里可以找到](https://github.com/angular-university/au-input)。

## 目录

本文涉及如下内容：

* 内容投影解决什么问题？
* 一个从内容投影中获益的示例组件
* 组件设计问题 1 - 支持所有的 HTML input 属性
* 组件设计问题 2 - 与 Angular Forms 集成
* 组件设计问题 3 - 捕获模板内的纯浏览器事件
* 组件设计问题 4 - 自定义第三方的 input 属性
* 初始设计的关键问题
* 使用内容投影设计同样的组件
* 如何通过 `ng-content` 对投影的元素应用样式
* 与投影内容交互
* 多道内容投影
* 结论

## 内容投影解决什么问题？

我们从头开始，为了理解内容投影，我们需要理解该特性试图解决什么问题。
不会误用该特性的最好方式，就是实现一个不使用内容投影的组件，看看我们会遇到什么问题。

### 我们构建的目标

我们的 Font Awesome 输入框组件外观类似于标准的 HTML input 框，除了在框中多了一个小的图标。

该图标可以是任何 Font Awesome 图标，我们先看一下这个组件。

### 封装普通的 HTML 

在 input 框中添加图标是常见的模式，可以使得输入框更便于用户识别。例如，看看下面的输入框。

![](https://raw.githubusercontent.com/angular-university/au-input/master/images/icons.png)

注意通过图标和占位提示信息，我们甚至不需要左边的 label，尤其是在移动设备上。

### 组件如何工作

我们知道，正常的 input 元素不能显示图像，但该组件看起来像原生的 input 元素，它还支持蓝色的焦点框，并支持 tab/shift-tab。

那么，怎么实现呢？组件内部通常使用这些常见的 HTML 模式

* 组件内，提供一个纯 input 元素和一个图标，封装在 div 元素内
* 隐藏掉 input 元素的边框，在封装的 div 元素上添加类似的外观框
* 我们在 input 元素上检测 `focus` 和 `blur` 事件，通过这些事件来处理封装 div 上的边框。

如你所见，我们仍然需要一堆窍门来使得组件看起来像一个普通的 Input 元素。

### 设计目标

我们采用这个非常常见的方式来实现该 Angular 组件。我们希望该组件可以：

* 易于与其它 Angular 组件和指令组合
* 与 Angular Forms 良好集成

为了该想法，我们看看采用不使用内容投影的实现方式，并看看会遇到什么问题。

先看看该组件会如何使用。

如你所见，该组件是自定义的名为 `fa-input` 的 HTML 元素，有一个输入框和一个图标，输出文本框中的值。

这是实现该组件非常自然的方式，它很可能是第一次尝试所采用的设计。

但是该设计存在一系列重要问题，我们看看该组件是如何实现的，来理解为什么，然后看看内容投影是如何通过干净的方案解决的。

### 组件设计 - 初始尝试

这是我们初始的组件设计：

> 猜一猜该设计最大的问题是什么

如我们在模板所见，该设计主要的思路是通过一个图标和一个 input 元素实现。

在深入组件实现之前，我们先看样式问题：

基于这些样式，我们看到：

* 内部的 input 元素的边框和轮廓被删除了
* 我们在宿主元素上添加类似的边框，制造了纯 input 元素的错觉
* 该 Input 得到焦点是通过添加 `focus` 样式类到宿主来模拟的

我们回到组件类，来看看这些如何组装在一起。

* 作为组件公共接口的一部分，我们需要一个 `icon` 字符串属性，来定义显示的图标。
* 组件提供名为 `value` 的输出事件，每当 input 的值发生变化，提供最新的值
* 为实现得到焦点功能，我们需要检测 `focus` 和 `blur` 事件，基于此事件，我们通过 @HostBinding 动态添加和删除 `focus` l样式类

该实现是可以工作的，但是如何我们在应用中使用该组件，我们很快会遇到一系列问题。这里列出了 4 个问题。

##  组件设计问题 1 - 支持所有的 HTML input 属性
我们的组件意味着像原生 Input 元素，但是，它不支持任何标准属性。例如，类型为 email 的纯 input 带有 autocompletion 开关和占位符。

所有标准的浏览器属性我们的组件都不支持，这些只是该问题的一部分属性。

在 W3CSchool 中列出了 31 个属性，还不包括所有的 HTML ARIA 可访问行属性。

如果支持所有这些属性，我们就不得不做类似实现它们。

所以，也就是说，我们将不得不传递所有的 input 属性到内部的 input 元素上。

这很笨重，但是还可以实现。但是，除了该问题，我们还有其它的问题。

## 组件设计问题 2 - 与 Angular Forms 集成

另一个问题是，如果我们希望该组件作为 Angular Forms 的一部分怎么办？

在该场景下，我们就不得不传递所有的 form 属性，例如 `formControlName` 。

## 组件设计问题 3 - 捕获模板内的纯浏览器事件

如果我们需要检测标准的浏览器 DOM 事件怎么办？比如 `keydown` 事件。

这也可以通过冒泡所有的事件来处理，为组件提供类似的事件名称

这很笨重，但还是可以实现，但是现在，我们没有好的处理方式的地步了。

##  组件设计问题 4 - 自定义第三方的 input 属性

在构建表单的时候，第三方的系统可能提供自定义的 `data-` 开头的属性，对于整页提交的场景。

这阻止了更多的问题出现，因为我们不知道这些属性的名称。

此刻，我们看到该设计对于大量常见场景不能很好的提供支持。

所以，该设计的主要问题是什么呢？

## 初始设计的关键问题

关键问题是我们隐藏了组件内部的 Input 元素。

因此，我们创建了一个栅栏隔断了外部模板与内容的纯 Input 元素。

> 这是所有设计问题的根源

隐藏模板内部的 input 元素导致了整个的问题，因为我们需要传递所有的属性和事件来支持它们。

好消息是，使用内容投影我们将可以支持上面所有的场景，以及更多。

## 使用内容投影设计同样的组件

我们重新设计该组件的接口，不再隐藏内部的 input 元素，我们以内容投影的方式提供。

注意，我们不再提供 input ，相反，我们将它放在 `fa-input` 自定义元素的 `conent` 中。

该方式实际上在标准的 HTML 元素中非常常见，例如 select .

Angular 核心支持在组件中做类似的工作。

我们实际上可以查询组件 HTML 标记中的任何内容，并在内部组件中使用，使用 `@ContentChild` 和 `@ContentChildren` 装饰器。

我们还可以做的更多

这意味着我们可以拿到 `fa-input` 中的内容部分，然后再内部的模板中使用它，使用 `ng-content` 投影。

新版本的组件仍是不完备的：它不支持焦点模拟的功能。

但是，它解决了上面的所有问题，因为我们可以直接访问该 input 元素。

然而，新版本的组件意外引入另一个问题，看下面的 Input 框。

![](https://s3-us-west-1.amazonaws.com/angular-university/blog-images/input-double-border.png)

是否注意到它有双重边框？看起来我们删除 Input 边框的工作没有生效！

还有，焦点功能缺失了。

看起来我们使用 `ng-content` 解决了许多问题，我们仍然有两个关键问题：

* 如何修饰投影的元素？
* 如何与投影的内容交互？

## 如何通过 `ng-content` 对投影的元素应用样式

我们先理解为什么原来的样式处理不再对 `ng-content` 工作。

为什么不再工作？因为这些组件的样式会有唯一的。

这些奇怪的标识是什么？我们看看在页面中的组件的运行时：

这是简单版本的 HTML，可以帮助我们更好地理解发生了什么？

* 在 `fa-input` 模板中的每个 icon 都应用了 `_ngconent-c0` 属性，它对该组件唯一。
* 所有组件的样式只对有该属性的元素生效
* 这意味着组件的样式不会影响到投影的 input 内容，因为它没有这个特定的属性 `_ngcontent-c0`
* 这是正常的，因为该 Input 来自 `fa-input` 之外的模板

### 修饰投影的内容

为了修饰投影的 Input 元素，以删除双边框，我们需要将样式修改为类似下面的方式：

新的样式如何工作呢？我们拆开看：

* 我们为样式添加 `:host` 前缀选择器，意味着该样式仅在组件内应用
* 然后应用 `::ng-deep` 修改器，这意味这样式不仅仅作用于组件内的 HTML 元素，还会映像到任何子元素。

下面是实际的运行时 CSS



如你所见，样式仍然作用于组件，但是，还会深入到运行时的内部，包括投影的 input 元素！

这里展示了如何修饰投影的内容。现在我们处理第二个问题：如何与投影的内容交互，并模拟焦点功能。

## 与投影内容交互

为了能够模拟焦点功能，我们需要 `fa-input` 输入组件知道投影元素何时得到焦点以及失去焦点。

我们不能与 `ng-content` 交互，例如在它上面定义事件监听器等等。

相反，最好的与投影的 Input 交互的方式是应用新的独立的指令到 input 上。

我们先递减名为 `inputRef` 的指令，然后应用到 input 元素上。

我们有机会使用同样的指令来跟踪 Input 元素是否获得焦点。

下面是指令：

* 定义焦点属性，基于原生的 input 是否获得焦点，它被设置为 true 或者 false
* 原生元素的 focus 和 blur 事件使用 @HostListener 修饰器检测。

我们现在使用该指令，并在 Font Awesome 输入组件中注入它，有效地使我们与投影的内容进行交互。

如我们所见，我们通过 `@ContentChild` 装饰器来注入 `inputRef` 指令。

然后，使用该指令和它的 `focus` 属性，我们可以通过 `@HostBinding` 来设置 `focus` 样式类。

使用新的实现方式，我们现在有了全功能的组件，使用超级简单，隐式支持所有的 Input 属性，样式，可访问性等等，以及 Angular Forms，使用内容投影，这些都变得可能了。

在当前的实现中，我们使用 `ng-content` 投影了全部的 `fa-input` 内容，但是，如果只投影一部分呢？

## 多道内容投影

现在我们看看，我们不仅希望投影 input 部分，还包括了图标部分，这也可以通过内容投影来实现。

在 `fa-input` 的内容部分，我们可以放置多种类型的内容，例如：

```html
<fa-input icon="envelope">
  <i class="fa fa-envelope"></i>
  <input inputRef type="email" placeholder="Email">
</fa-input>
```

我们可以消费不同类型的内容，通过在 `ng-content` 上使用 `select` 属性。

```html
@Component({
  selector: 'fa-input',
  template: `
    <ng-content select="i"></ng-content>
    <ng-content select="input"></ng-content>
  `})
export class FaInputComponent {
   ...
}
```

两个选择器用于不同的特定内容，我们还可以根据特定的 CSS 类来查找元素，以及组合多个选择器。
例如，这个选择器查找名为 `test-class` 的元素。

```html
<ng-content select="input.test-class"></ng-content>
```

还可以捕获不匹配任何选择器的元素。例如，

```html
@Component({
  selector: 'fa-input',
  template: `
    <ng-content select="i"></ng-content>
    <ng-content></ng-content>
  `})
export class FaInputComponent {
   ...
}
```

## 结论
知道 `ng-content` 如何工作非常重要。

## See also
* <https://blog.angular-university.io/angular-ng-content/>
